# STL(Standard Template Library)

## What?

So stl is standard template library and it contains different functions and data structures which we can use to solve problems.

## Why?

STL is basically a helper library thing now we can implement every function like sorting or searching from scratch, but let say we have a bigger problem then using STL not only saves our time but also decrease the time in which we can solve the problem.

# Slides

![alt text](image.png)

![alt text](image-1.png)

![alt text](image-2.png)

- **Note** in the above slide we can see that both the arguements passed should be of same data type otherwise compiler throws an error. 
- Also the datatype or class object should be able to perform those operations in order to not have compilation error, **example:** let say you are trying to compare strings but there's no direct way of comparing strings.

![alt text](image-3.png)

- Similar to function we can use templates for classes

![alt text](image-4.png)
- **Random Access Iterators**: Basically positions or indexes in case of an array.
- You can see that they are pointers only coz for sorting from a[0] to a[9] we pass in (a, a+10) and this is the way we did pointer arithematic.
- **Note** r is not included in the sorting.

![alt text](image-5.png)

![alt text](image-6.png)

- So basically when using sort we can sort things other than int and float we just need to tell them how to compare things. This is achieved using `operator<` or `comparator` function.

- Using `operator<`
  - As you see this is defined in the struct itself.'
  - Inside you define the logic of how and what to compare. 
  - With this we can normally call `sort()` fn

![alt text](image-7.png)

- Using `cmp()`
  - This can be used when you don't want to modify your struct.
  - In this case we need to pass the comparator fn too as arg in `sort()` fn
  - **KEEP IN MIND** you don't end up using equalities, check BE CAREFUL in slides.

![alt text](image-8.png)

- Here the function is directly created inside the `sort()` fn.

![alt text](image-9.png)

- All elements before the n-th element are less than or equal to it and all elements after the n-th element are greater than or equal to it. 
- This basically works like partition fn.
- NOTE ELEMENTS ARE NOT FULLY SORTED.

![alt text](image-10.png)

![alt text](image-11.png)

- **NOTE** it only removes consecutive rendundant element, so if repeated elements are scattered first sort the elements then apply `unique()`.

- In the code above we find the length of the new array that will be generated by `unique()`.
  - unique returns a pointer (iterator) to the "logical end" of the new sequence
  - and to find the length, we subtract the first pointer from the end pointer.
- We then put 0 at the end to mark the end of string

![alt text](image-12.png)

![alt text](image-13.png)

![alt text](image-14.png)

![alt text](image-15.png)

![alt text](image-16.png)

![alt text](image-17.png)

![alt text](image-18.png)

![alt text](image-19.png)